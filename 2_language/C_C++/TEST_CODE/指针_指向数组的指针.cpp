#include<iostream>
using namespace std;
void fun1(int *p,int N);
void fun2(int(*p)[5],int N);
void fun3(int b[5],int N);
int main()
{
	int a[5]={1,2,3,4,5};
	if(a==&a[0])cout<<"Yes"<<endl;//a的值是它第一个元素的地址
	int *p=&a[0];
	cout<<"sizeof a:"<<sizeof a<<endl;
	cout<<"sizeof p:"<<sizeof *p<<endl;
	//虽然p与a有相同的指针效果，但是有本质区别，p只是指向一个int变量的指针，sizeof算出
	//的长度是一个元素长度的4个字节，而a是一个指向数组的指针，它指向的object占20个字节
	//a代表的是一整个数组块，虽然它的地址是第一个元素的地址，a++加的是4，而&a++相当于
	//pa++加的是20。不过仍然可以简单地认为，在用法上相当于第一个元素的指针，而在概念上
	//编译器却知道它代表了一个数组(主要自己尚不知，指针的自加自减和sizeof的计算用的是
	//不是同一套标准，如果概念和用法不同那么这个标准推断是不一样的，因为直观上讲，
	//元素的指针自加减就是元素的长度，数组的指针自加减就是数组的长度，问题在于a代表
	//的到底是一个元素的地址概念还是一个数组地址的概念，如果是元素地址，那么它凭什么
	//可以代表数组，而用起来如一个元素指针，如果是一个数组概念，又为什么对其自加减
	//计算的是一个元素的长度，而对其地址，也即其指针pa得到的是一个20的加减。
	//综合来讲可以理解为：a相当于一个数组的名称，它的指针值应该等于&a，但它自身的这个
	//名称却可以当一个元素指针来用。就好比一个类对象，它的名称可以代表一个值，可以是
	//它成员变量的值或地址等（取决于如何重载，编译），而它的地址却需要另外来定义指针
	//数组中对a的自加自减相当于编译器赋与它的一个额外功能，这个额外功能是能过将a[i]转化
	//为*(a+i)来实现的，且要把a当作一个元素指针来用，因为它的值就是第一个元素地址，好比
	//对象的名称其实代表的就是对象的地址值（直接寻址方式），但是如果再定义对象的指针
	//相当于又开辟的一个空间专门存储对象的地址（间接寻址），核心问题就是是否将变量，对象
	//名，数组名赋于了其它意义
	//如果要定义与a等价的指针，如下：
	int (*pa)[5]=&a;
	cout<<"sizeof pa:"<<sizeof *pa<<endl;//*pa与a完全等价，但pa++加的是20个字节

	fun1(a,5);
	fun2(&a,5);
	fun3(a,5);

	return 0;
}

//void fun1(int p[],int N)//与下面等价,该写法自己觉得并不规范，p[]表示什么，没见过，而编译器其
//实就是按*p来处理的
void fun1(int *p,int N)
{
	for(int i=0;i<N;i++)
		cout<<*(p+i)<<" ";
	cout<<endl;
}
void fun2(int(*p)[5],int N)
{
	for(int i=0;i<N;i++)
		cout<<(*p)[i]<<" ";
	cout<<endl;
}
void fun3(int b[5],int N)
{
	for(int i=0;i<N;i++)
		cout<<b[i]<<" ";
	cout<<"b的长度是:"<<sizeof b<<endl;
	//编译系统把b当作指针来处理的，而且不考虑5这个数，所以上句输出的长度是
}