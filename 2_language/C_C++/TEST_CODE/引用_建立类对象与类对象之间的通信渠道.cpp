//1 在一个类对象中定义一个普通变量或一个函数或一个指针或另一个类成员变量或另一个类成员函数或另一个类对象的引用，那么即使不在这两个对象之间建立函数通信接口，已经实现了等价调用的通信渠道，因为只是名称不同，它们指的是同一段内存。非常有用。
//2 这个机制与在一个对象中定义另一个对象（可以是变量函数或类）的地址是一个原理和本质，只不过第条用的是别名，第二条用的是相同的地址。可能这就是为什么很多C语言高手很喜欢指针以及指针的指针的原因。
//3 指针和引用的使用，要么在函数传递中建立联系，要么在类建立时建立联系，本质是一样的，在函数参数中使用指针或引用，相当于两个函数域内的变量使用了相同的地址，建立了公共区，而在两个类中定义指向同一地址的指针或定义针对同一个变量或函数或类对象的指针或引用，则相当于在同个类域内建立了一个公共区，使用相同的地址。
//4函数是一个域，类也是一个域，域与域之间的通信除了值复制传递就是指针和引用传递信息。再或全局变量传递。总之类中成员定义另一个对象的指针或引用只不过是跨跃了通常情况下的函数域，从而拓展到了类内域，而不仅仅是类成员函数域。
//5将一个函数或变量和和另一个函数或变量打包成一个类，则这两个对象拥有了相当的域（类域），于是一个可以使用另一个，而不需要参数传递。
//6通信机制的建立有几种：要么建立函数域与函数域通信（双方均定义函数接口），要么建立对象域与对象通信（直接定义指针或引用指向一个公共区，这个公共区可以是普能变量或new分配的，或就是其中一个类的成员），再者或建立函数域与对象域通信（函数参数是普通变量的引用就是常见的情况），常见的做法是将这几种混用，使得域与域之间的通信变得更加多样，高效。
#include <iostream>
//#include<string>
#include<vector>
using namespace std;
class B
{
public:
	B(double& b):aa(b){}
	double &aa;
};
class A
{
public:
	A():t(a){}//将内部类对象成员声明为外部类中数据的引用，相当于建立了一个外部类和内部类之间通信渠道
	double a,b,c;
	double d;
	B t;
};
int main()
{
	A a;
	a.a=10;
	cout<<a.t.aa<<endl;
	B b(a.a);//将另一个类中数据声明为本类中的引用；相当于在一个类和另一个类之间定义了一个通信渠道机制
	cout<<b.aa<<endl;
	a.a=100;
	cout<<b.aa<<endl;
	return 0;
}



