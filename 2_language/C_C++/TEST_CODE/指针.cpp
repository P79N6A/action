//1对一个空指针使用delete没有任何作用，什么也不做。利用这个特点，在C++类的赋值运算符重载和复制构造函数的
//设计中，如果被拷贝对象是一个不再需要的隐式临时变量(即右值)，对于动态分配的内存，数据拷贝时可以只复制地址值，
//且把右值中的指针值改为空指针0就可以了。
//原内存数据不会在右值析构函数中销毁，也不分配新的内存，这样可以大大提升效率。这就是右值引用的原理，
//如果是左值，当然原动态分配的内存一定要被复制，保证每个对象处理各自的数据。
//2养成好习惯：一个指针在定义时就要赋空指针，防止误用；如果指针将用到指向一个动态分配的内存，
//一定同一时间考虑它在什么
//时候释放内存；一旦该指针值被赋于其它指针（多个指针指向同一段内存），就要考虑是哪个指针使用delete，
//如果该指针不再使用，应立即赋值0，
//如果该指针还要使用，考虑多个指针对同一数据的操作冲突问题和delete问题，对于不使用的指针，应该立即赋0
//多次释放同一地址内存和引用一个未知的地址都会造成程序崩溃
//如果指针p的值所在的地址处没有某个成员函数等，使用p调用这个函数，程序会崩溃
//3可以通过右值引用和地址运算符得到一个隐式变量的“地址”。像int&&p=a+10;这样的表达式，p是a+10的右值引用
//实际中间，p并不真正是a+10的引用而是，一个新的地址，并把a+10的值拷贝过去，右值引用真正的作用是不
//改变类中的动态分配内存，而其它数据，如指向动态内存的指针，常规栈分配的内存都是要被复制和拷贝的。所以
//右值引用不是真正的引用，而是针对动态内存分配和释放问题的技术方法
//4用*访问一个空指针会使得程序运行崩溃，如：double*d=0;cout<<*d<<endl;是错误的
#include<iostream>
using namespace std;
int main()
{
	{
		int *p1=0,*p2=0;
		p1=new int(10);
		cout<<"*p1:"<<*p1<<endl;
		p2=p1;p1=0;
		delete p1;//指针为0 ,delete没有任何作用
		cout<<"*p2:"<<*p2<<endl;
		delete p2;
		cout<<"*p2:"<<*p2<<endl;//删除指针所指的内存后输出的是乱码,所以养成习惯如果还要用到p2，紧跟着对p2赋0
		//防止不必要的误用error
		p2=0;
	}
	cout<<"---------------------------------------------"<<endl;
	{
		int a=10;
		int&&p=a+10;//要使用C++11进行测试,定义右值引用
		int*p1=&p;//通过右值引用找到地址，这个地址不是真正的a+10的地址，而是与其数值相等的新的地址
		cout<<"&a:"<<&a<<'\t'<<"a:"<<a<<endl;
		cout<<"p1:"<<p1<<'\t'<<"*p1:"<<*p1<<endl;
	}
	return 0;
}

