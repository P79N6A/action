//1基础类型、函数和自定义类型（打包类型）统一构造成了程序活动中的个体。在打包个体中，个体可以包含个体，一个个体可以是另一个个体的友元。
//2只有函数和自定义类型是有隐私的，而且可以实现某种功能。
//3对于两个个体A和B之间的交互，如果个体B调用自己的函数，是个体B主动完成相应的事宜。如果个体A希望B完成某个功能，那么A要告诉B如何完成这个功能，即如何去做。这个功能与B调用的自己的函数必定类似。这个如何做的方法function如何告诉，有几种方式：其一，将function定义为A的成员函数或第三方函数，以B为引用或指针，直接在这个函数中对B的函数成员和数据成员进行操作（操作权限的多少视是否声明为B的友元或B定义了足够的接口），其二，将这个function（仍然要在B外定义为第三方函数或者是A的成员函数）直接发送或者打包成类发送给B，让B在之前不知道处理方法的情况下主动依据这个方法进行操作（如果function定义为B成员函数，相当于提前已经知道了处理方法）。这时相当于B定义了一个成员函数，以function为参数来对自己进行处理，仍属于主动处理。提前未知且主动处理的情况下，这种function的定义和B对于这个function的处理充满技巧（有时候这种处理可能很复杂，如果B要接收不同的函数，那么其处理的数据及function的调用参数还要依据这个function而定，而这时这个function最好是一个打包的function类对象，且重载了operator()，可以直接以对象名当函数使用或者以其成员函数来进行处理）。但是这个理念很新，它相当于你告诉朋友按照某种方式主动去做事。而另外两种就好比，你知道朋友会这个方法让朋友主动去做和你直接帮朋友去做。
//4内置类型的交互就很简单了，拿来即用，用对即可。几乎所有基础操作均是如此。
//5如果使用模板可以处理更多的类型。
//6下如下面测试代码中所列的三种方式，第一种方式适用于一些简单的操作，也就是举手之劳的事，第二种方法要相当于一个通用接口，可以接收很多方法进行不同的处理，而这个方法本身可能不是被处理类必需的，第三种方法主要用来定义类中针对数据类型典型的操作。
#include<iostream>
using namespace std;
class B;
class A
{
public:
	void cmdByihuo(B&b);//一：直接操作B；直接帮朋友去做。只有在声明为B的友元后才可以处理B的私有成员
	static void Ayihuo(int& x)//二：要告诉的朋友的操作方法（也可以在类外声明为一个普通函数）， 这个函数要声明为静态的，在不定义对象的情况下就可以使用，否则在B中使用时必须定义A的对象能过对象来调用函数，但这时B就失去了可以以相同的接口使用第三方类传递给它函数的能力，定义为静态与定义为全局函数实质是一样的，只是使用方法不一样。
	{x^=1;}
};
class B
{
private:
	int pr;
public:
	int pu;
public:
	B(){pr=0;pu=0;}
	void yihuo()//三：你知道朋友会，朋友自己做
	{pu^=1;pr^=10;}
	void study(void (*func)(int&))
	{(*func)(pu);}//二：朋友按你告诉的方法做
};
void A::cmdByihuo(B&b)
{
	b.pu^=1;
	//或b.yihuo();
}
void test(A&a,B&b,int way)
{
	int n=10;
	while(n--)
	{
		if(way==1)
			a.cmdByihuo(b);
		if(way==2)
			b.study(A::Ayihuo);
		if(way==3)
			b.yihuo();
		cout<<b.pu<<" ";
	}
	cout<<endl;
}
int main()
{
	cout<<"-------------------------------------------------"<<endl;
	{
		A a;B b;
		test(a,b,1);
		test(a,b,2);
		test(a,b,3);
	}
	return 0;
}